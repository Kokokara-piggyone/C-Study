//2019/11/30 周五 
（一）内存
	内存四区:
 
		a)代码区  
		b)全局区
		c)栈区 由系统自动开辟，自动释放，并不是很大。 
		d)堆区 由程序员动态开辟的内存，手动开辟，手动释放，很大。
 
（二）地址:把内存以单个字节为单位分开，对每一个字节编号，这个编号就是地址。
			编号是连续且唯一（不可更改）
			取址运算符：& 单目运算符 只比优先级 ()[]. 低，结合性从右至左 
首地址:一段内存空间中第一个最大存储单元的地址。注意！是最大存储单元 
		int a;-------->字节 
		int a[5];----->元素 
		int a[2][2];-->一维数组
		 
（三）指针变量 1.用来存放地址的变量 2.内存大小4B（或8B）固定
	地址是一些编号，一种数据。
	整数------>int a;
	字符------>char c;
	小数------>float b;
	地址------>指针变量
		A)指针变量的定义：
			数据类型 *变量名; 
			int *p; 
			//定义一个指针变量，存的是地址 
			//int指明指针指向的数据为整型
			//*指明p这个变量是一个指针变量
		B)指针变量的赋值：
			p=&a; //p指向a,即p保存了a的地址 
		C)指针变量的引用：
			访问a这个int变量
				1. 直接访问
				2. 指针访问：访问p这个指针变量保存的地址存储的内容 
						printf("%d\n",*p); //*为取值运算符 ，&为取址运算符 
							*取值，即返回某一个地址中的值，单目 右至左
							注意：定义指针变量时，*指明p这个变量是指针变量
								  而在非定义情况下，*用作取值
	补充：
	1.野指针：不能明确指向的指针变量
				int *p //p里面保存的地址不确定 ，p指向不明确，存在重要数据被修改的可能。 
	2.空指针：（int *p=NULL; 用于处理野指针）
			类比 int *p; 空指针为 void *p; 不明确存入数据类型时，明确后可以转换成其他数据类型
		D)指针变量的运算 即指针偏移，去访问地址旁边的一些内存 包括+ - ++ --
	 		指针变量的加减，是以指针所指向的类型空间为单位进行偏移的。
			 如加一则char偏1，int偏4，float偏4，double偏8 

摘要：①首地址:一段内存空间中第一个最大存储单元的地址。注意！是最大存储单元
	  ②指针变量的加减，是以指针所指向的类型空间为单位进行偏移的。
	  	 		
（四）一维数组与指针
		1.定义一个一维数组，数组名是这个数组的首地址。 
			int a[5];
			a指向数组的首地址a[0],即&a[0],a[0]为int型元素，所以a的类型是int*（因为是地址啊！所以有*这个取址符），当a+1时，输出数值+4
			&a这个地址指向整个数组，所以&a类型为int(*)[5]，当&a+1时，输出数值+20 
		2.访问一维数组元素
			下标法：即a[i] 
			指针法： 
					int a={1,2,3,4,5};
					int *p=a; //p指向a[0]
					//p是a[0]的地址（即首地址），那么*p就是a[0]的值
					//p+1是a[1]的地址，那么*(p+1)就是a[1]的值
					//综上，p+i是a[i]的地址，*(p+i)就是a[i]的值 
					for(int i=0;i<5;i++)
					{
						printf("%d "，*p);
					} 
	//由于单目运算符的优先级比双目运算符高，所以*(p+i)需加括号，而*p++（均为单目，由右至左）无需加括号。
	//二者的区别： *(p+i)中，i变化而p没有变化，*p++中p是变化的（自增运算）
	//如果执意用a，那么*(a+i)可以但*a++不可以，原因是a虽为首地址，但a更是数组名，数组名++没啥意义。
	//这里只是把a看成一个指针常量，只是看成，实际并不是。
再次强调：数组名是这个数组的首地址，首地址是一段内存中第一个（最大）存储单元的地址。
 
（五）二维数组与指针
	1.定义一个二维数组：int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
	数组名为a，a是这个二维数组的首地址
	首地址是什么？ 一段空间内存中最大的第一个存储单元，在这里就是第一个一维数组。 
	拓展：比如声明一个三维数组，int a[2][3][4];
			可以拆为2个二维数组，3个一维数组，4个整型元素，
			所以这个三维数组的首地址就是第一个二维数组的地址 。 
 	综上分析可知，a指向a[0]这个一维数组，a的类型是 int(*)[4];
 	所以，a+1，增加16B,
	a[0]是一维数组的数组名，那么a[0]指向a[0][0]，a[0]的类型是int*，所以a[0]+1，增加4B(到这已经完全转到一维数组的方法了！) 
	辨别：以下四个地址均相同,然类型不同 
		a--------------->int(*)[4]
		a[0]------------>int(*)[3][4]
		&a[0]----------->int*
		&a[0][0]-------->int
	a是二维数组的首地址，a是二维数组中的一个存储单元（一维数组），
	a指向一个一维数组，类型为int(*)[4],所以a+1就加4*4=16 
	&a指向整个二维数组，类型为int(*)[3][4],所以&a+1就加3*4*4=48 
	2.访问二维数组元素 位于m行n列 
		下标法 a[m][n]
		指针法 *(a[m]+n) 
				*(*(a+m)+n) //a指向a[0] ,所以a+1指向a[1](均指向一维数组)，那么*(a+1)就是a[1]的首地址 

（六）多维数组：*下拆，&上搭。

拓展：
		指针数组： int*[]
		数组指针： int(*)[] 
		函数指针：
		指针形参的函数：
		结构体指针：
		字符串与指针：
		指向指针的指针：
		
		数据结构： 
		 
//2019/11/30 周六

len=strlen(a)------->len=sizeof(a)/sizeof(a[0]) 

指针应用场景：
1.
函数返回多个值，某些值只能通过指针返回 
传入的参数实际上是需要保存带回的结果的变量 
/* 
#include<stdio.h>

void minmax(int a[],int len,int *min,int *max) //定义指针变量min和max 
{
	int i;
	*min=*max=a[0]; //指针变量min和max均指向a[0] *为取值符，a[0]实际上为*(a+0) 
	for(i=1;i<len;i++)
	{
		if(a[i]<*min) //*取值 
			*min=a[i];//*取值------语法糖 
		if(a[i]>*max)
			*max=a[i];
	}
}

int main()
{
	int a[]={1,2,3,4,5,6,7,8,9,12,13,14,16,17,21,23,55};
	int min,max;
	minmax(a,sizeof(a)/sizeof(a[0]),&min,&max);//&取址符 
	printf("min=%d max=%d\n",min,max);
	return 0;
}

主函数main中为实参，自定义函数中为形参
实参是一个地址传给形参
*/

2. 
函数返回运算的状态，结果通过指针返回
常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错 
但是当任何数值都是有效的可能结果时，就得分开返回
/* 
//如果除法成功则返回1，否则返回0 
#include<stdio.h>

int divide(int a,int b,int *result)
{
	int ret=1;
	if(b==0) ret=0;
	else
		*result=a/b;
	return ret;
}

int main()
{
	int a,b,c;
	scanf("%d%d",&a,&b);
	if(divide(a,b,&c))
	{
		printf("%d/%d=%d\n",a,b,c);
	}
	return 0;
}
*/ 

常见错误：
定义了指针变量，还没有指向任何变量，就开始使用指针,即野指针. 
 

Dev-cpp快捷键

删除当前行--------------------------------->ctrl+d
恢复上一步--------------------------------->ctrl+z	 
复制当前行并粘贴在当前行的下一行----------->ctrl+e	 
光标返回首行末----------------------------->ctrl+pd up	
双视图------------------------------------->ctrl+m	
整体左移一个tab位置------------------------>shift+tab 
整体右移一个tab位置------------------------>tab 



